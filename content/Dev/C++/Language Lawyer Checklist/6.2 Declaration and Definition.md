---
title: 6.2 Declaration and Definition
slug: 6-2-declaration-and-definition
date: 2026-01-12
tags: []
category: Dev
draft: false
---

## 1. 声明与定义的判定逻辑 (The Logic of Definition)

* **定义的本质**：定义是导致编译器为实体**分配存储空间**（对象/变量）或**生成代码**（函数）的行为。

依据 `[basic.def]` 第 2 段，标准列举了 **22 种** ((2.1) ~ (2.22)) 特殊情况。若一个声明符合以下任一条件，则它**仅仅是声明**，不构成定义（即不分配存储空间或生成函数实体）。

以下为工程开发中最为核心的典型情况（完整列表请参阅标准原文）：

1.  **无函数体的函数声明** (2.1)
    * `void f();`
2.  **包含 `extern` 说明符且无初始化器** (2.2)
    * `extern int a;` （若写 `extern int a = 1;` 则变为定义）
    * 包含链接说明：`extern "C" void f();`
3.  **类定义中的非内联 (non-inline) 静态数据成员** (2.3)
    * `struct S { static int x; };` （需在类外定义）
4.  **详尽类型说明符 (Elaborated type specifier)** (2.5)
    * 即前向声明：`struct S;`
5.  **类型别名声明** (2.9, 2.10)
    * `typedef int Int;` 或 `using Int = int;`
6.  **Using 声明** (2.12)
    * `using std::vector;` （仅引入名字，不创造实体）
7.  **模板参数** (2.7)
    * `template <typename T> ...` （T 仅为占位符）
8.  **推导指引 (Deduction Guide)** (2.13)
    * `MyVector(int) -> MyVector<int>;`
9.  **静态断言声明 (Static assert)** (2.14)
    * `static_assert(true);`
10. **显式实例化声明 (Explicit Instantiation Declaration)** (2.21)
    * `extern template void f<int>();`
11. **未定义的模板声明** (2.20)
    * `template <typename T> void f();`

> **注**：除上述及标准中列出的其他特定情况外，任何声明均被视为定义。

---

## 2. 深度解析：全局变量与 ODR 陷阱

### 2.1 `extern` 与初始化的互斥性
标准规定：包含 `extern` 说明符且**没有**初始化器的声明不是定义。
反之，**一旦包含初始化器，`extern` 被覆盖，该语句成为定义。**

* **危险范式**：
    ```cpp
    // 在头文件中：
    extern int b = 1; // 这是一个定义！
    ```
* **工程后果**：若此头文件被两个 `.cpp` 包含，两个翻译单元都会生成符号 `b` 的强定义。链接阶段将报错 **Multiple Definition**。
* **正确范式 I (Pre-C++17)**：
    * 头文件：`extern int b;` (纯声明)
    * 实现文件 (.cpp)：`int b = 1;` (定义)
* * **正确范式 II (C++17+)**：
    * **头文件**：`inline int b = 1;` （ODR 安全的定义）

### 2.2 `extern "C"` 的函数体
`extern "C"` 仅影响**名字修饰 (Name Mangling)**，不改变声明/定义的判定规则：C++ 函数 void h() 编译后符号名可能是 _Z1hv（包含参数信息）加上 extern "C" 后，符号名强制变成 _h（为了兼容 C 语言）。
* `extern "C" void h();` 是声明。
* `extern "C" void h() { ... }` 是定义。
    * 若写在头文件且无 `inline`，同样会导致多重定义错误。
> * **声明 (`extern "C" void h();`)**：用于引入 C 语言写的库函数。
> * **定义 (`extern "C" void h() { ... }`)**：用于**导出** C++ 实现给 C 语言调用（作为接口网关），或用于动态库插件入口（防止 Name Mangling 以便 `dlsym` 查找）。

---

## 3. 演进：C++17 Inline Variables

这是针对 Header-only 库和静态成员初始化的重大改进。

### 3.1 语义变更
`inline` 关键字从仅作用于函数，扩展至变量。
* **语义核心**：**Allow Multiple Definitions**。允许在多个翻译单元中定义同一个变量，前提是定义内容完全一致。

### 3.2 解决的痛点
1.  **静态成员初始化**：
    * **Old**: 类内声明 `static int count;` -> 类外定义 `int A::count = 0;`。
    * **New**: 类内直接定义 `static inline int count = 0;`。
2.  **全局配置/Header-only 库**：
    * 无需单独提供 `.cpp` 文件来存放全局变量定义，直接在 `.hpp` 中写 `inline int config = 0;`。

### 3.3 实现机制 (Weak Symbols / COMDAT)
编译器将 `inline` 变量标记为 **Weak Symbol** 或置于 **COMDAT** 段。
* **链接器行为**：当链接器发现多个同名的 Weak Symbol 时，不会报错，而是**随机保留一个**（通常是第一个），丢弃其余的。这保证了全程序地址唯一性。

---

## 4. 编译优化：Extern Template

### 4.1 显式实例化声明 (Explicit Instantiation Declaration)
语法：`extern template void f<int>(int);`

* **编译器行为**：即便当前翻译单元能看到模板 `f` 的完整源码（函数体），也**强制抑制**代码生成。
* **符号表状态**：生成一个 **Undefined Symbol (U)**。
* **目的**：**Build Time Optimization**。防止 N 个翻译单元编译出 N 份相同的模板汇编代码。
* **对比**：
    * 普通函数声明：因看不到源码而无法生成。
    * `extern template`：看得到源码，但受命不生成。

---

## 5. C++26 新特性：Consteval Block

### 5.1 语法与定义
语法：`consteval { ... }`
标准归类：**consteval-block-declaration** (属于声明)。

### 5.2 核心价值
* **Guarantee (保证)**：块内代码**必须**在编译期执行。若包含无法在编译期求值的逻辑（如访问运行时变量），编译器报错。
* **声明属性**：尽管块内包含执行逻辑，但它不产生运行时的机器码，不引入运行时实体，因此在语法分类上属于声明。
* **场景**：服务于 **P2996 (Static Reflection)**，用于在编译期执行代码注入、元数据生成等逻辑。

