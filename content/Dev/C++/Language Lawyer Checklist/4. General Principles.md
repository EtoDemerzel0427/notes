---
title: 4. General Principles
slug: 4-general-principles
date: 2026-01-10
tags: [C++]
category: Dev
draft: false
---

> 原文链接：https://eel.is/c++draft/intro

这一节的主要内容是C++语言设计与编译器实现哲学的基本原则，它相当于C++语言的一个“宪法”。它定义了代码如何被解释、编译器必须做什么，以及最著名的“As-if"规则。

## Diagnosable Rules

这一节定义了C++编译器厂商的责任边界。其中包括：
1. 编译器必须报错的情况 (Diagnostic Message)
   标准规定了编译器必须发出诊断信息（通常是错误或警告）的场景：

   - Must Report: 违反语法/类型系统（Syntax error, Type mismatch），除非标准说这是 UB 或 No diagnostic required。
   - Must Report: `#warning` (C++23加入), `#error`, `static_assert` 失败。
   - Must Report: 契约 (Contracts) 检查在编译期失败 (C++26 新特性)。

2. 编译器不需要报错的情况

    如果规则说 "no diagnostic required" 或者导致 "undefined behavior"，编译器不需要报错，也不需要保证程序运行结果。这就是 UB 的“法律”来源。

3. 实现定义的行为与文档义务 (Implementation-defined Behavior)
  这是合规性中容易被忽略但重要的一点。区别于 UB，对于 Implementation-defined behavior（例如 int 的字节数、字节序）：
  - 编译器可以选择具体的实现方式。
  - 必须编写文档说明该选择。
  - 如果没有文档说明，则该编译器不符合标准。

4. Hosted vs Freestanding (宿主式 vs 独立式) 这是写嵌入式或操作系统内核时的关键区分。
   - Hosted: 你的电脑环境 (Windows/Linux/macOS)。必须支持完整的 STL（包括 std::thread, std::fstream 等）。
   - Freestanding: 裸机环境。不需要操作系统。标准库被阉割，只需支持部分头文件（如 <cstddef>, <limits>, <new>, <type_traits> 等，最近 C++23 大幅扩展了独立式实现的范围，包括了 <ranges> 等）。

5. 扩展 (Extensions) 的合法性 

   GCC/Clang 有很多扩展（比如 __attribute__）。但必须遵循以下原则：
     - 非干扰性: 扩展不能改变标准 C++ 代码的语义。
     - 诊断后接受: 比如 void main()。虽然它违反标准，但编译器可以在发出警告（履行诊断义务）后，作为扩展允许其编译通过。
     - 注：使用了扩展的代码不再是“严格合规的程序 (Strictly Conforming Program)”。

    例子：编译器不能把 void main() 变成合法的标准行为，因为它违反了标准对 main 返回值的规定。但编译器可以说“如果你写了非标准的 void main，我会给个警告（诊断），然后我允许你运行它”。这就是第 11 点的意思：Diagnose, then accept.

6. 契约 (Contracts) 与 强化实现 (Hardened Implementation) 

   这里出现了 Contracts (contract assertion) 和 Hardened Implementation。 这是 C++26 正在努力标准化的内容。

   - 契约 (Contracts): C++26 引入了 pre (前置条件), post (后置条件) 和 contract_assert。标准允许编译器提供三种语义模式：

      - Ignore: 完全忽略契约（零开销）。
      - Enforce: 运行时检查。如果违反，必须终止程序。
      - Observe: 运行时检查。如果违反，调用回调函数（通常用于日志），但不强制终止。

    - 强化实现 (Hardened Implementation): 这是一种特定的标准库实现模式。在此模式下，违反特定标准库函数的前置条件（例如 std::vector 越界访问），不再被视为未定义行为 (UB)，而是保证会导致程序终止 (Guaranteed Termination)。这使得“程序崩溃”成为一种符合标准的、确定的安全行为。

7. Erroneous Behavior  [C++26]
  在 `[intro.abstract]`第 6 段的末尾，C++26 引入了一个全新的行为类别：Erroneous Behavior (EB)。它介于“正常行为”和“未定义行为 (UB)”之间。

    - **定义**: Erroneous Behavior 指的是程序中存在的错误逻辑（Bug），但标准规定了实现必须如何处理它。 与 UB 不同，标准禁止编译器假设 EB 永远不会发生。这意味着编译器不能基于 EB 进行激进的优化（如删除代码路径），但允许在 EB 发生时发出诊断信息或终止程序。

    - **典型实例**：读取未初始化的自动变量 ([P2795 Erroneous behaviour for uninitialized reads](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2795r3.html)) 这是 C++26 定义的第一个也是目前最重要的 EB 实例。

      ```cpp
      void foo() {
          int x;      // C++26 默认视为 EB
          int y = x;  // 读取未初始化变量
      }
      ```
      - C++23 及以前: 这是 UB。编译器可以认为此路径不可达，从而删除整个函数或产生随机行为。
      - C++26: 这是 EB。

    - **默认行为**: 编译器通常会执行默认初始化（如置零），确保读取到的值是确定的，而不是内存残留的垃圾数据。

    - **安全性**: 这一改变消除了因未初始化读取导致的信息泄露和“时间旅行”式优化风险。

    - **性能回退** (`[[indet]]`): 如果开发者需要极致性能，不希望承担默认初始化的开销，可以使用 [[indet]] 属性显式声明：

      ```cpp
      int x; [[indet]]; // 显式标记为 Indeterminate
      int y = x;        // 此时回退为 Undefined Behavior
      ```
### 8. UB 的止损点：Observable Checkpoint 与 Defined Prefix [C++26]

这是 C++26 为了限制“未定义行为 (UB)”破坏范围而引入的重要补丁 ([P1494 Partial program correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1494r5.html))。

在旧标准中，一旦程序某处出现 UB，整个程序的行为（包括 UB 发生前的部分）理论上都是未定义的。C++26 引入了两个概念来修正这个问题：

* **Observable Checkpoint (可观察检查点)**:
    这是程序执行流中的“存档点”。以下操作构成检查点：
    1.  **I/O 完成时**：例如 `std::cout << ... << std::endl`（因为 `endl` 刷新了缓冲区，数据被交付给宿主环境）。
    2.  **显式调用**：调用 C++26 新增的 `std::observable_checkpoint()` 函数（位于 `<utility>`）。
    3.  **Volatile 访问**：读写 volatile 变量。

* **Defined Prefix (已定义前缀)**:
    标准规定：如果程序最终发生了 UB，那么**在 UB 发生之前、且被最近一个 Checkpoint 隔开**的那部分代码行为，是**必须**得到保证的。

    **示例对比**：
    ```cpp
    void risk() {
        // 情况 A: 只有打印，没 Flush
        std::cout << "Loading..."; 
        // 缓冲区可能还没刷新，没有建立 Checkpoint
        
        int* p = nullptr; 
        *p = 42; // UB 发生！
        // 结果：编译器可能回溯优化，导致 "Loading..." 根本打印不出来。
    }

    void safe() {
        // 情况 B: 打印并 Flush
        std::cout << "Loading..." << std::endl; 
        // 建立 Observable Checkpoint (存档成功)
        
        int* p = nullptr;
        *p = 42; // UB 发生！
    }
    ```
    * **在 C++26 中**：对于情况 B，标准保证在程序崩溃前，用户**一定**能看到 "Loading..."。这段安全输出的代码就是该执行路径的 **Defined Prefix**。
    * **意义**：这为调试器和日志系统提供了法理依据，确保“死前遗言”不会被编译器的激进优化吃掉。
## The Abstract Machine (抽象机与执行模型)

C++ 标准并不直接规定代码在 x86 或 ARM 芯片上如何运行，而是定义了一个**抽象机 (Abstract Machine)**。编译器的工作是将源代码在抽象机上的行为，映射到具体的物理硬件上。这一映射过程的核心原则如下：

### 1. The "As-If" Rule
这是 C++ 编译器优化的基石。

* **核心定义**: 编译器生成的二进制代码，其运行结果必须与抽象机执行该源代码的结果完全一致（**仅限于可观察行为**）。
* **推论**: 只要不改变程序的“可观察行为”，编译器可以进行任何优化（删除代码、重排指令、改变内存布局等）。
* **示例**:

```cpp
int main() {
    int a = 10;
    int b = 20;
    int c = a + b; // 纯计算，无副作用
    return 0;      // 只有返回值是可观察的
}
```

* **抽象机视角**: 分配 `a`, `b`, `c` 的内存 -> 执行加法 -> 销毁变量 -> 返回。
* **物理机视角**: 编译器可以直接生成 `xor eax, eax; ret` (直接返回 0)。中间的加法计算被完全消除，因为它对外部世界不可见。

### 2. Observable Behavior (可观察行为)
既然“如同规则”允许编译器随意修改不可见的行为，那么定义什么是“可见的”就至关重要。标准明确规定，只有以下三类操作构成**可观察行为**：

1.  **Volatile Access**: 对 `volatile` 修饰的变量进行读写。这通常用于内存映射 I/O (MMIO) 或信号处理，编译器必须保证读写的次数和顺序与代码一致。
2.  **I/O Operations**: 调用标准库 I/O 函数（如 `printf`, `std::cout`, `std::fstream`）产生的数据传输。
3.  **Program Termination**: 程序调用 `main()` 返回、`std::exit()` 或 `std::abort()` 等导致的程序终止状态。

**补充**: 只要不涉及这三点，编译器可以假设你的代码运行在真空中，可以随意折叠、重排或删除。

### 3. UB 与优化的关系 (Reachability & "Time Travel")
标准规定：*如果程序的任何执行路径包含未定义行为 (UB)，则该程序的行为完全未定义。*

这一点被现代编译器用作强大的优化假设：**编译器假设 UB 永远不会发生。**

* **逻辑推导**: 如果某条代码路径会导致 UB，编译器会认为这条路径是**不可达 (Unreachable)** 的。
* **所谓“时间旅行”**: 虽然标准描述的是 UB 发生“之后”行为未定义，但编译器基于“不可达”的假设，可以删除导致 UB 之前的判断逻辑。

**示例**:
```cpp
void foo(int* p) {
    int x = *p; // 1. 如果 p 是空指针，这里发生 UB
    if (!p) {   // 2. 检查 p 是否为空
        return; // 3. 错误处理
    }
}
```
* **优化后**: 编译器看到第一行解引用了 `p`，因此推断 `p` 绝不可能为空（否则就是 UB，而 UB 假设不发生）。于是，编译器将第 2-3 行的空指针检查直接删除。
* **结果**: 如果你真的传了空指针，程序在第一行崩溃，看起来像是第一行的 UB “回到过去” 删除了后面的检查。

### 4. 顺序与交互 (Sequencing & Interactive Devices)
在“如同规则”下，编译器虽然可以重排指令，但必须遵守特定的顺序约束，这构成了用户眼中的“已定义前缀”或执行流。

* **I/O 顺序保证**: 标准保证，符合标准语意的 I/O 操作顺序在物理机上必须保持一致。
* **交互式设备**: 对于终端（Interactive Devices），标准要求实现表现出“提示-输入”的逻辑顺序。
    * 即：如果代码写了 `cout << "Password:"; cin >> pw;`，程序必须确保在等待用户输入之前，"Password:" 已经显示在屏幕上（即隐含了一次 flush 操作）。
* **注意**: 这里的顺序仅限于“可观察行为”之间。两个 `printf` 之间的纯计算逻辑，依然可以被随意优化。

### 5. 抽象机的非确定性 (Nondeterminism)

在 `[intro.abstract]` 第 3 段，标准明确指出 C++ 抽象机是 **非确定性 (Nondeterminism)** 的。这打破了“代码只有一种运行方式”的直觉。

* **定义**:
    针对 **Unspecified Behavior**（未指明的行为），标准并不规定唯一的执行路径，而是定义了一个“允许的行为集合”。
    这意味着，对于给定的源代码和输入，抽象机可能存在多条合法的执行轨迹。只要物理机器的运行结果落在这些轨迹中的**任意一条**，该实现就是合规的。

* **典型实例：函数参数求值顺序**
    ```cpp
    // Global state
    int g = 0;
    int a() { g += 1; return g; }
    int b() { g *= 2; return g; }

    void func(int x, int y) { ... }

    // 调用
    func(a(), b());
    ```
    * **路径 A**: 先 `a()` 后 `b()` -> `g` 变 1，再变 2。传参 `(1, 2)`。
    * **路径 B**: 先 `b()` 后 `a()` -> `g` 变 0，再变 1。传参 `(1, 0)`。
    * **结论**: 路径 A 和路径 B **都是**正确的。标准允许编译器在不同的优化级别、不同的架构上自由选择。这解释了为何同一段“合规”代码在不同环境下的行为可能不一致。
   > 注：在这个例子中，决定这个顺序的是调用约定 (Calling Convention)，而而调用约定是 ABI (Application Binary Interface) 的一部分。如x86下的`cdecl` ABI规定参数必须从右向左压栈，而x64 System V ABI - Linux/macOS 则规定参数通过寄存器传递，第一个参数放 `rdi`，第二个放 `rsi`。此时（针对这个例子）编译器就比较自由了：它可以先算 `a()` 放入 `rdi`，再算 `b()` 放入 `rsi`，也可以先算 `b()` 放入 rsi，再算 `a()` 放入 rdi。这完全取决于编译器的优化器觉得哪种顺序能更好地利用流水线或寄存器。

### 6. 实现的资源限制 (Implementation Limits)

`[intro.compliance.general]` 第 9 段划清了“数学理想”与“物理现实”的界限。

* **定义**:
    C++ 抽象机在理论上拥有无限的资源（无限的内存、无限的递归深度、无限长的标识符）。但在现实中，编译器受限于物理硬件和设计约束。
    因此，标准规定：**合规的实现 (Conforming Implementation) 可以拒绝编译一个在语法和语义上完全正确 (Well-formed)、但过于复杂的程序。**

* **文档义务**:
    标准虽允许限制，但建议（Encouraged）编译器在文档中明确这些限制的具体数值。常见的限制包括：
    * **模板递归深度**: 如 GCC 默认限制为 900 层（`-ftemplate-depth`）。
    * **标识符长度**: 某些旧链接器可能只识别前 1024 个字符。
    * **源代码行数**: 单个文件的大小限制。
    * 详见标准附录 `[implimits]`。