---
title: 5. Lexical conventions
slug: 5-lexical-conventions
date: 2026-01-12
tags: [C++]
category: Dev
draft: false
---

# C++ 标准解析：词法约定与翻译阶段 [lex]

本文旨在系统性梳理 C++ 标准文档中的第 5 章 **Lexical conventions [lex]**。我们将依据 C++ Abstract Machine 的运作机理，详解源代码如何从物理存储转化为可供语法分析的 Token 流。

这一节在内容上可能更像是词法分析阶段的一本字典，对C++程序员（而非编译器作者）来说很多东西可能并没有那么重要。个人觉得比较重要的是理解翻译阶段的不同的phase和顺序，这样就能知道诸如“为什么不能用宏来生成注释”的问题的答案（因为注释早在Phase 3就已经替换掉了）。

## 1. 翻译阶段 (Phases of Translation) [lex.phases]

C++ 编译模型被严格划分为 9 个逻辑翻译阶段。实现必须表现得“如同”这些阶段是串行发生的一样，尽管实际编译器可能将其合并处理。

### Phase 1: 字符集映射与规范化
- **输入**：物理源文件。
- **处理**：
    1.  **编码转换**：将物理源文件的字节序列解码为源代码字符集（Source Character Set）。自 **C++23** 起，实现必须支持 UTF-8 源文件。
    2.  **BOM 处理**：如果文件以 U+FEFF (Byte Order Mark) 开头，该字符被删除。
    3.  **行尾规范化**：将各种平台的换行符序列（如 `CR+LF`、单独的 `CR`）统一映射为单个换行符（new-line character）。
    4.  **Trigraphs**：三字符组（如 `??=`）在 C++17 中已被移除，不再处理。

### Phase 2: 行拼接 (Line Splicing)
- **输入**：规范化后的字符流。
- **处理**：
    - 查找反斜杠字符 `\` 后紧跟换行符的序列。
    - **删除**该反斜杠和换行符，将物理源行拼接为逻辑源行。
    - **C++23 变更**：在拼接前，实现必须先剔除反斜杠与换行符之间的任何空白字符（whitespace）。这意味着 `\` + `[空格]` + `\n` 现在是良构的拼接行为，而在此之前属于未定义或导致拼接失效。
    - 如果非空源文件不以换行符结尾，视作追加了一个换行符。

### Phase 3: 预处理符号化 (Preprocessing Tokenization)
- **输入**：逻辑源行。
- **处理**：
    1.  **分解**：将源文件分解为 **预处理记号 (Preprocessing Tokens)** 和空白序列。
    2.  **注释处理**：将每一段注释（`/*...*/` 或 `//...`）替换为**单个空格字符**。注意换行符被保留。
    3.  **UCN 识别**：识别通用字符名（Universal Character Name, e.g., `\u0061`）。
        - **例外**：在 `#include` 的头文件名称（`header-name`）以及字符串/字符字面量中，不进行 UCN 替换。
        - **常规**：在标识符上下文中，UCN 被映射为对应的 Unicode 字符。
    4.  **最大吞噬 (Maximal Munch)**：词法分析器总是消耗尽可能多的字符来构成一个合法的预处理记号。

### Phase 4: 预处理执行 (Preprocessing)
- **输入**：预处理记号序列。
- **处理**：
    1.  执行预处理指令（`#include`, `#define`, `#if`, `#pragma` 等）。
    2.  **宏展开**：宏调用被替换为定义的记号序列。
    3.  **递归包含**：`#include` 指令命名的文件递归执行 Phase 1 至 Phase 4。
    4.  **清理**：所有预处理指令被删除。此时，记号之间的空白字符不再具有语法意义。

### Phase 5: 字符集转换
- **输入**：预处理记号序列。
- **处理**：
    - 将字符字面量和字符串字面量中的字符序列，从源字符集映射到**执行字符集 (Execution Character Set)**。
    - 处理转义序列（Escape Sequences），如 `\n`, `\xHH`。

### Phase 6: 字符串拼接
- **输入**：预处理记号序列。
- **处理**：
    - 邻接的字符串字面量记号被连接。
    - 例如：`"Hello " "World"` 转换为 `"Hello World"`。
    - 此操作发生在宏展开之后，因此宏产生的邻接字符串也会被拼接。

### Phase 7: 词法转换与语法分析 (Translation)
- **输入**：预处理记号。
- **处理**：
    1.  **Token 转换**：将 *Preprocessing Tokens* 转换为真正的 *Tokens*（关键字、标识符、字面量、操作符）。
        - 此时进行关键字识别（如 `int`, `class`）。
    2.  **语法与语义分析**：构建抽象语法树（AST），进行类型检查、重载决议。
    3.  **模板实例化**：根据需要实例化模板。
    4.  **常量求值**：计算 `constexpr` 和 `consteval` 上下文。
    - **C++26 静态反射与副作用**：在此阶段，编译器可能为了解析完整类上下文（Complete-class Context），需要非线性地执行类内部的 `consteval` 块，以处理潜在的代码注入或元数据生成（P2996/P2564）。

### Phase 8: 实例化与模板链接
- **处理**：
    - 处理那些在 Phase 7 中未完成的模板实例化单元。
    - 收集实例化产生的符号。

### Phase 9: 链接 (Linking)
- **处理**：
    - 解析外部符号引用。
    - 链接库组件。
    - 生成最终程序映像。

---

## 2. 关键词法规则详解

### 2.1 预处理数字 (Preprocessing Numbers) [lex.ppnumber]
在 Phase 3 中，数字常量的识别采用极度宽泛的规则。任何以数字开头，后续跟随数字、字母、`_`、或者 `e+`/`p-` 等序列的组合，均被视为单个 `pp-number`。

* **技术细节**：这种贪婪匹配早于语法分析。
* **示例分析**：序列 `10e+1`。
    * 词法分析器将其识别为**单个** `pp-number`（包含字符 `1`, `0`, `e`, `+`, `1`）。
    * 在 Phase 7 转换为数字字面量时，由于 `10e+1` 是合法的浮点数格式（`100.0`），转换成功。
    * **错误示例**：宏定义 `#define MACRO 10e`，随后的代码 `MACRO+foo` 展开为 `10e+foo`。这是一个合法的 `pp-number`，但在 Phase 7 转换为浮点数时会失败（`invalid suffix`），而不会被解析为 `10e` 加 `foo`。

### 2.2 最大吞噬与 Parser 修正：模板右尖括号 [temp.names]
这是一个经典的“词法与语法冲突”案例。

* **Phase 3 (Lexer 行为)**：
    * 遵循最大吞噬原则（Maximal Munch）。
    * 当遇到 `>>` 字符序列时，Lexer **必须**将其识别为右移操作符（Right Shift Operator, `>>`），而不能是两个大于号。这是上下文无关的铁律。
* **Phase 7 (Parser 行为)**：
    * 在 C++11 之前，Parser 接收到 `>>` token，但此刻它期望一个 `>` 来闭合模板参数列表，导致语法错误。
    * **C++11 修正**：标准引入了特定的语法上下文检查规则。
    * 当 Parser 处于解析 **模板参数列表 (template-argument-list)** 的状态时，如果它读取到了一个 `>>` token，它会将该 token **重新解释 (reinterpreted)** 为两个连续的 `>` token。
* **总结**：Lexer 依然“笨拙”地执行贪婪匹配，是 Parser 利用语法上下文对 Token 流进行了动态修正。

### 2.3 整数字面量类型推导 [lex.icon]
C++ 标准严格规定了整数字面量的类型推导顺序。值得注意的是，十进制与非十进制字面量的推导列表是异构的。

| 字面量形式 | 进制 | 类型推导候选列表 (从上至下匹配) | 符号性特征 |
| :--- | :--- | :--- | :--- |
| `42` | 十进制 | `int`<br>`long int`<br>`long long int` | **仅有符号类型**。若数值溢出 `long long`，程序非良构。 |
| `0x2A` | 十六进制 | `int`<br>`unsigned int`<br>`long int`<br>`unsigned long int`<br>`long long int`<br>`unsigned long long int` | **符号/无符号交替**。允许推导为无符号类型以适应位模式。 |

### 2.4 字符字面量与 C++20 变更 [lex.ccon] & [lex.string]
* **多字符字面量**：`'ABCD'` 类型为 `int`，其值由实现定义（Implementation-defined）。不建议在可移植代码中使用。
* **UTF-8 字面量变更**：
    * **C++17**：`u8"text"` 类型为 `const char[]`。
    * **C++20**：`u8"text"` 类型变更为 **`const char8_t[]`**。这破坏了与其 `const char*` 接口的向后兼容性，是词法层面的一项重大语义变更。

### 2.5 头文件名称解析 [lex.header]
在 Phase 3 中，如果上下文处于 `#include` 指令内，词法分析器会切换至特定模式以识别 `h-char-sequence`（`<...>`）或 `q-char-sequence`（`"..."`）。
* 在此序列内部，**不执行** UCN 替换。
* **目的**：确保包含反斜杠的路径（如 Windows 路径）不会被错误地解释为 Unicode 转义序列。

---

## 3. C++26 静态反射与词法展望

基于 P2996 提案，C++26 将引入新的词法操作符以支持静态反射。

* **反射操作符 (Reflection Operator)**：**`^^`** (Double Caret)。
    * 语法：`^^T` 或 `^^expr`。
    * 从词法角度，这消除了单脱字符 `^` 与 Clang Block 扩展语法的潜在歧义。
* **拼接操作符 (Splicer)**：`[: ... :]`。
    * 用于将 `std::meta::info` 元数据还原为源代码结构。

## 4. 总结

C++ 的编译过程并非直接从字符到语义，而是经过了严格分层的流水线处理。

1.  **Phase 1-2** 处理物理文件的编码与格式（行拼接）。
2.  **Phase 3** 负责符号化，确立了 token 的边界，且在此阶段注释被移除（替换为空格），UCN 被处理（但在 include 等特定区域除外）。
3.  **Phase 4** 处理预处理逻辑，仅操作记号流，不理解 C++ 语法。
4.  **Phase 7** 才是传统意义上的“编译”，类型系统、作用域查找、字面量语义在此生效。

理解这一流程对于排查宏展开错误、字符编码问题以及复杂的字面量解析行为至关重要。