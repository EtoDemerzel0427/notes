---
title: 6.1 Basics.pre
slug: 6-1-basics-pre
date: 2026-01-12
tags: [C++]
category: Dev
draft: false
---

标准文档第六章篇幅较长，这里我们分为若干篇Wiki来分别总结。

## 1. 名字 (Name) 与 同名判定 (Identity)

### 1.1 定义
在 C++ 标准中，**Name** 是一个统称，指代用于标识实体的符号。它不仅仅是标识符 (Identifier)。
合法的 Name 包括四类：
1.  **Identifier** (e.g., `foo`, `x`)
2.  **Conversion-function-id** (e.g., `operator int`)
3.  **Operator-function-id** (e.g., `operator+`)
4.  **Literal-operator-id** (e.g., `operator""_m`)

### 1.2 同名规则 (Identity of Names)
判定两个名字是否“相同” (The same)，直接影响 ODR (One Definition Rule) 和重载决议。
* **标识符**：字符序列完全一致。
* **操作符**：操作符符号一致。
* **转换函数**：目标类型**等价 (Equivalent)**。类型等价 (`[temp.over.link]`) 意味着 `typedef`/`using` 别名不影响名字的同一性。即 `operator int` 与 `operator MyInt` (若 `using MyInt = int`) 是同一个名字。

> **附注：操作符名字与实体的区分**
> [basic.pre] Para 4.3 规定，只要操作符符号相同（如均为 `operator+`），名字即相同。
> * **名字 (Name) 层面**：`void operator+(A, A)` 与 `void operator+(B, B)` 拥有完全相同的名字。
> * **实体 (Entity) 层面**：它们指代两个不同的函数实体。
> * **机制**：操作数类型（Signature）不参与名字同一性的判定，而是作为后续 **[over]** 章节中重载决议（Overload Resolution）区分不同实体的依据。

---

## 2. 声明 (Declaration) 与 查找 (Lookup)

### 2.1 声明的完备性
**Declaration** 是将 Name 引入程序的唯一机制。
标准列举了 18 种声明形式（涵盖变量、结构化绑定、Lambda 捕获、Concepts 参数、合约结果等），确立了“无声明，无名字”的原则。

### 2.2 解析依赖 (Parsing Dependency)
[basic.pre] Note 5 指出：名字的语义属性（是否指代类型/模板）决定了语法解析的路径。
* **规则**：遇到名字时，必须立即进行 **Lookup ([basic.lookup])**。
* **后果**：C++ 的词法分析、语法分析与语义分析无法完全解耦。

### 2.3 深度解析：上下文相关文法 (Context-Sensitive Grammar)
C++ 解析器的复杂度显著高于 Java 或 Go，其根本原因在于 C++ 语法的**二义性 (Ambiguity)** 导致 AST 构建依赖于符号表查找（Lookup）。

* **经典二义性案例**：语句 `T * p;`
    * **情形 A**：若 `T` 是类型，则为指针声明（Declaration）。AST 节点为 `Declaration`。
    * **情形 B**：若 `T` 是变量，则为乘法表达式（Expression）。AST 节点为 `BinaryOperator`。
* **编译器行为**：Parser 无法仅凭语法结构做出判断，必须暂停 Parse，执行 Lookup 查询 `T` 的元数据。这被称为 "The Lexer Hack"。
* **与其他语言对比**：
    * **Java**：无指针声明语法，且声明结构固定，语法通常是上下文无关的（Context-Free）。
    * **Go**：通过引入关键字（如 `var`）或倒置声明顺序（`p *T`），在语法层面消除了二义性。Go 编译器在 Parsing 阶段无需知道符号含义即可构建 AST。

---

## 3. 实体 (Entity)

### 3.1 定义
**Entity** 是名字在逻辑层面的指代对象。
包括：值 (Value)、对象 (Object)、引用 (Reference)、函数、类型、模板、命名空间等。

### 3.2 名实关系 (Name-Entity Mapping)
* **映射**：名字 **指代 (Denotes)** 实体。
* **底层实体 (Underlying Entity)**：
    * 通常情况下，声明引入的实体即为底层实体。
    * **特例**：`typedef`, `using` (Type Alias), `namespace alias`。
    * 对于别名，名字指代的实体是别名本身，但其**底层实体**是它所指向的原始实体。

---

## 4. 变量 (Variable) 的严格定义

这是本节在术语上最易混淆的概念，标准给出了排他性的定义。

### 4.1 定义集合
**Variable** 必须由以下两种声明之一引入：
1.  **对象 (Object)** 的声明。
2.  **引用 (Reference)** 的声明。

### 4.2 关键排除项 (Exclusion)
**非静态数据成员 (Non-static data member) 不是变量。**

* **逻辑依据**：变量隐含了**独立**的存储期 (Storage Duration) 和作用域。非静态成员的生命周期完全依附于其所属的类对象，不具备独立性。
* **静态成员 (Static data member)**：属于变量。因为它具备独立的静态存储期。

### 4.3 局部实体 (Local Entity)
特指具有**自动存储期 (Automatic Storage Duration)** 的变量、结构化绑定或 `*this`。该定义通常用于约束 Lambda 捕获行为或协程帧的构造。

---

## 5. 总结与推论 (Summary & Implications)

1.  **链接性的前提**：第 10 段指出，只有涉及“同一个实体”时才讨论跨翻译单元的链接。由于非静态成员不是独立的变量（实体），因此讨论非静态成员的 Linkage 是无意义的。
2.  **对象模型的严谨性**：标准明确区分了 Subobject（如成员）和 Variable。这一区分在后续讨论指针类型（`T*` vs `T C::*`）和生命周期时至关重要。
3.  **声明即定义的前置**：本节确立了所有名字必须由声明引入，为后续 6.2 节区分“哪些声明也是定义”奠定了基础。